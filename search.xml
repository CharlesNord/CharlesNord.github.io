<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[matplotlib]]></title>
      <url>%2F2017%2F04%2F07%2Fmatplotlib%2F</url>
      <content type="text"><![CDATA[本文介绍 matplolib 常用函数，包括设置坐标轴范围、坐标刻度、标签。具体内容请见下方链接：jupyter notebook]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FDDB]]></title>
      <url>%2F2017%2F04%2F07%2FFDDB%2F</url>
      <content type="text"><![CDATA[本文简要翻译了 FDDB: A benchmark for Face Detection in Unconstrained Settings. Introduction人脸检测发展很快，但是很多算法所报道的结果不能复现，因此需要建立一个新的评价标准来评估算法表现。现有数据库存在如下问题： Sung et al. 的数据库：虽然来源各异，甚至包括从报纸上扫描的图片，但是所有的人脸都是正面垂直照。 Rowley et al. ：与上面的数据库相似，并包括了平面内旋转的人脸 (faces with in-plane rotation)。 Schneiderman et al. ：将上面的两个数据库结合，并增加了人的侧脸图片 (profile face images)，构建了著名的 MIT+CMU 数据库。 上面这些数据库都是灰度图，不能有效评估彩色人脸检测器。之后的一些数据库也包含了彩色图片，但是存在缺点。例如 GENKI 数据库收集了不同姿态的彩色人脸图（左右/上下 $\pm 45^\circ$，正面旋转$\pm20^\circ$），但是每幅图只有一张人脸。类似的 Kodak，UCD 和 VT-AAST 数据库包含了带遮挡的人脸，但是数据集太小，不能作为评判标准。 本工作的贡献是建立了一个新的数据库，解决了上述问题。这个数据库包含： 2845 张图片，其中包含了 5171 张人脸； 包含了各种遮挡，高难度的姿态，低分辨率以及对焦模糊的人脸； 用椭圆来标定人脸区域； 同时包括灰度图和彩色图。 当前的评判标准存在的另一个问题是，缺少对程序表现的评价指标。某个算法报道出来的表现，取决于它对“正确检测”的定义。本文设置了一个评判框架，包含下面几个部分： 一个程序，对比算法输出和groundtruth的相似度 两个严格、精确的方法来评估算法在数据集上的表现。这两种方法是为不同的应用设计的 实现上述步骤的源代码 本文按如下结构展开： Section 2：评价不同人脸检测方法的困难之处；Section 3：概括本数据集的构建过程；Section 4：介绍一种半自动化的方法，用于去除数据集中的重复图片；Section 5：本数据集的标定过程细节；Section 6：介绍本数据集的评判框架。 Comparing face detection approaches基于可以接受的头部姿态变化程度，人脸检测算法可以被分为如下几类： 单一姿态：只能检测标准正面或者侧面像 旋转不变：可以接受脸部在画面中的旋转 多视角：画面中的头部可以左右上下旋转 姿态不变：对人的头部朝向没有任何限制 本文构建的数据库用来评价最普遍的情况，也就是姿态不变。 评价人脸检测算法的第一个挑战是，对程序的预期输出没有达成一致：有些算法输出的是矩形框，有些是任意形状的框，还有些是输出眼睛等脸部特征的位置。另外还有的算法输出了头部的姿态。 本工作限定在对基于区域的输出的评价（evaluation of region-based output）。因此用任意尺寸、形状和朝向的椭圆来标定图像中的人脸。这比之前的矩形框更贴合人脸，并且也易于用参数表示（椭圆公式）。在 Section 5 中介绍标定步骤。 FDDB: Face Detection Data set and Bench-markBerg et al. 根据新闻图片和提取它们的新闻标题创建了一个数据库，图片包含了各种姿态、光照、背景。里面的人脸包含各种表情、动作和遮挡，因此很贴近现实中的识别场景。但是这里面的人脸是通过自动化的人脸检测算法标定的，因此并不客观。本数据库采用了该数据库的所有图片，并为里面的所有图片中的人脸做了标定。 Construction of the data setBerg et al. 的数据库是从 Yahoo 新闻网收集的。很多新闻虽然来源不同，但是用的图片相同，因此数据库里面有很多重复图片，这些图片虽然内容相同，但是可能有微调（剪裁、对比度修正），导致了所谓 near-duplicat images。这种近似的图片会影响到对算法评估的客观性，因此需要去重。 Near-duplicate detection作者从 Berg et al. 的图-标题对中（根据时间顺序）选出了 3527 张图。如果用朴素的方法去重，需要对比大概 12500000 次（估计是每幅图和剩下的图对比，$3527\times (3527-1)=12436202$）。另一种方法是每次同时展示一组图片，然后人工为这组图片去重，由于图片太多也不现实。 网络搜索领域研究的一个课题是找出 near-duplicate images。然而在网络搜索中，放缩的重要性要大于在图片库中找出所有的近似图片。因此也不能直接使用这种手段。Zhang et al. 提出了一种基于 stochastic attribute relational graphe (ARG) （随机属性关系图）匹配的计算密集型算法。这些 ARGs 通过检测图片中的几个 interest points 来表示整幅图的构成部分和每部分之间的关系。为了计算两幅图的 ARGs 的匹配分数，采用了一种图变换的生成模型。这种方法在寻找近似图片方面能够达到很高的召回率： $$recall=\frac{relevant\ documents\cap retrieved\ documents}{relevant\ documents}$$ （recall 也就是 true positive rate，能够最大程度地检测出和当前图相关的图保证不会遗漏，但是可能检测到很多和当前图不相关的图，汪精卫：宁可错杀1000不放过一个）因此很适合用在这里。为限制误检率，采用 Algorithm 1 的算法，循环地交替聚类和人工检查。Algorithm 1 的 3-5 步采用 spectral graph-clustering 方法进行聚类。然后，人工检查每个非单一样本的小聚类，如果这个小聚类中所有的图片都是一个来源，那么就用其中的一幅图片代替整个类。 在聚类步骤，作者根据 collection 中的所有图片创建了 fully-connected undirected graph G，其中 ARG-匹配得分作为每两幅图之间连线的权重。 根据 spectral graph-clustering approach，作者计 graph G 的 (unnormalized) Laplacian $L_G$ 。 $$L_G = diag(\mathrm(d))-W_G$$ 其中 d 是 set of degrees of all nodes in G，$W_G$ 是 G 的 adjacency matrix。图 G 到 $L_G$ 的前几个特征向量张成的子空间的投影，可以为每对节点（一个节点代表一张图片）提供一个很有效的距离测度。作者在这个投影空间中用 mean-shift clustering with a narrow kernel，得到图片的聚类。 利用该算法，7 次迭代，人工发现了 103 个聚类，消灭了 682 张重复图片。 人脸区域标定预标定：在 2845 （3527 张原有的图减 682 张重复的图）张图片中，画出每个人脸的矩形框。长或宽小于 20 像素的人脸被排除，得到了 5171 个人脸标定。有些地区不太好确认是否标定为人脸，原因包括低分辨率，遮挡，头部角度等。作者采用多人标定，取平均值的手法。对于下面这些情况，标定者需要将其排除人脸：两只眼睛同时被遮挡、无法估计（定性地 qualitatively）位置、尺寸或者朝向。Appendix A 中描述了标定流程。 Elliptical Face Regions作者表示人的头部可以用两个椭球近似，进而认为用椭圆标定人脸比用矩形更准确，所以采用椭圆标定。采用的椭圆参数有：中心坐标、长轴/段轴的长度、以及方向。由于现实中人脸在 2 维的投影不是规则的椭圆，所以用椭圆标定人脸很有挑战。为了使标定一致，人工按照下面的流程进行标定： 椭圆的长轴两个端点分别是人脸的下巴和椭球（用来近似人头的那个）最上端的点，椭圆不包括耳朵部分 对非正面的人脸，椭圆的至少一个横向端点与该侧耳朵与人脸的边界重合 细节见 Appendix A。 接下来需要设计一个一致且合理的评估标准。 Evaluation首先要做出几点假设： 每个检测结果都与它毗邻的图像区域对应 任何用于重叠区域融合或者相似检测去除的后处理步骤都已经完成 每个检测结果唯一对应一张人脸，不能出现对应多张或者一半人脸的情况。换句话说，一个检测框不能同时检测两个人脸，两个检测框不能组合起来检测一张人脸，如果一个程序用多个检测框检测到了人脸上不相连的区域，那么这里面只能有一个代表正确检测，其余的都为错误检测。 为了表达检测结果 $d_i$ 和标定 $l_j$ 之间的吻合度，采用 intersection over union 的算法： $$S(d_i, l_j) = \frac{area(d_i) \cap area(l_j)}{area(d_i)\cup area(l_j)}$$ 其中标定 $l_j$ 采用上文的椭圆。 为了便于人工标定，作者首先用程序对人脸的位置进行了估计。方法是：首先用皮肤分类器对图片的像素进行分类，分类器的输入是像素点的 hue 和 saturation 值（HSV: hue 色调，saturation 饱和度，value 亮度）。然后，皮肤连通区域包围的孔洞用 MATLAB 的 flood fill 算法进行填充。最终，基于连通区域的矩，计算得到其外接椭圆的各项参数，最后人工将调整这些参数。 Matching detections and annotations将检测结果和标注进行一一对应。最后剩下的问题是如何将一组标注和一组检测结果进行对应。对于好的检测结果，这个问题很好解决。但是对于大量 false positives (误检) 或者多个重叠的检测，这个问题就变得微妙和有技巧性了。下面我们将这个匹配标定框和检测结果的问题，规范化为在二分图中寻找最大比重的匹配。 （匹配方式比较复杂，临时我没搞懂Lecture 10.pdf Maximum Weight Matching in Bipartite Graphs） Evaluation metrics假设 $d_i$ 和 $v_i$ 代表第 i 个检测结果和它对应的标定。作者提出了下面两种测度，用来衡量该检测的得分。 离散得分(DS Discrete score)：$y_i = \delta_{S(d_i, v_i)&gt;0.5}$ 连续得分(CS Continuous score): $y_i = S(d_i, v_i)$ 这里再回顾一下评估物体检测算法的 ROC 曲线的画法： 根据 annotation 为所有 detection 的矩形框打上标签，如果一个 detection 的框与 annotation 框的 IoU 大于 0.5，那么它的标签就是 1，反之为 0，也就是文中的离散得分定为 1。 将所有图片中的所有检测框放在一起，按照 confidence score 从高往低排列（注意 detection score 和 confidence score 的区别，confidence score 是检测器输出的物体置信度得分，而 detection score 是根据预测的物体位置与实际标定的位置算出的得分）。 对于没有检测到的标定框（也就是没有 detection 框能够覆盖这个 annotation），将其标为正样本（detection score = 1），但是给它的 confidence score 定为负无穷。也排在检测框的序列后面。 从高往低调整 confidence score 的 threshold，例如当 threshold=1 时，没有 confidence score 能在 1 之上，故 True positive rate (TPR 或 recall) 为 0，同时，False positive rate (FPR) 为0。在 ROC 曲线上描出坐标原点这个点；假设 threshold=0.98 时，有 2 个 检测框的 confidence score 在 threshold 之上，其中一个与 annotation 的 IoU 大于 0.5（故标签为1，是正确的检测，属于 True Positive），另一个与 annotation 的 IoU 小于 0.5（故标签为0，是错误的检测，属于 False Positive）。那么，TPR 为 1 除以正确检测的总数（计数时包括那些排在检测框之后的未被检测到的 annotation），FPR 为 1 除以错误检测的总数（在 FDDB 中，并没有采用 FPR，而是直接采用 FP，也就是 False Positive 的个数）。这样，又在 ROC 曲线上描出了新的一个点；继续降低 threshold，描出更多的点，直到 threshold 降到负无穷+1（比负无穷稍大一点），将所有检测框都置为正检测。此时仍然有些 annotation 由于得分为负无穷，无法归为正检测，这样，其 FPR 为 1（若横轴为 FP，则此时其值为所有检测框中的负样本数），而 TPR 为该检测器能力的极限。 以上是传统的 ROC 曲线画法，其 detection score 要么是 1 要么是 0，完全取决于 detection 与 annotation 的 IoU 是否大于 0.5，因此这种做法比较粗糙。FDDB 给出了一种新的评估标准，detection score 不再是非0即1，而是直接采用 IoU 值，计算 TPR 时，将所有 threshold 之上的检测框的 detection score 加起来，除以正样本总数，例如某个 detection 与 annotation 的 IoU 为 0.9，那么它就相当于之前的评判标准的 0.9 幅 True Positive。 数据格式每个 annotation 文件的内容都是如下格式： 123456第 i 幅图的名称该幅图中人脸 annotation 的个数face f1face f2...第 i+1 幅图的名称 每个人脸的椭圆标定都用 6 个元素的元组来表示。$(r_a, r_b, \theta, c_x, c_y, 1)$ 前两者为椭圆的半长轴和半短轴，中间 $\theta$ 为长轴与水平方向的夹角，接下来两个元素为椭圆中心的坐标，最后一个为得分，由于是标定的groud truth，故得分为 1。对于 detection，得分为检测框对应的 confidence score。 detection 的形状既可以为矩形，也可以为椭圆形。若为矩形，其格式为 $(x, y, w, h, s)$ 分别代表矩形的左上角坐标，宽度，高度以及得分，其中得分 $s\in \{-\inf, +\inf\}$。 detection 若为椭圆形，其格式为 $(r_a, r_b, \theta, c_x, c_y, s)$。分别代表：半长、半短轴长度，长轴与横坐标轴的夹角，椭圆中心点坐标，confidence score。 代码下面的代码可以在图像中同时画出 annotation 和 detection。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import matplotlib.pyplot as pltimport matplotlib.image as mpimgfrom matplotlib.patches import Ellipseimport numpy as npimport os # 用于读取 detection 和 annotation # 返回字典列表，列表中每个元素为一个字典，包含的键有：图像名称，该图中脸的个数，脸的坐标def getRes_det(fdet): detFile = open(fdet,'r') det = detFile.readlines() detFile.close() res = [] for idx in range(len(det)): if '/' in det[idx]: im_res = &#123;&#125; im_res['name'] = det[idx].strip() num = int(det[idx+1]) im_res['num'] = num coord = [] for i in range(idx+2,idx+2+num): coord_str = det[i].split() coord_float = [float(i) for i in coord_str] coord.append(coord_float) im_res['coord'] = np.array(coord) res.append(im_res) return res # 在 res 中的每个元素中增加时间 键def getRes_time(res, ftime): timeFile = open(ftime,'r') tm = timeFile.readlines() timeFile.close() for i in range(len(res)): res[i]['time'] = float(tm[i]) return res # 画出 detection 和 annotationdef showRes(res, ann, thresh=0.5, class_name='face'): dets = res['coord'] inds = np.where(dets[:,-1]&gt;=thresh)[0] im_name = os.path.join('..','originalPics',res['name']+'.jpg') im = mpimg.imread(im_name) fig, ax = plt.subplots(figsize=(6,6)) ax.imshow(im, aspect='equal') for i in inds: bbox = dets[i, :4] score = dets[i, -1] ax.add_patch( plt.Rectangle((bbox[0], bbox[1]), bbox[2], bbox[3], fill=False, edgecolor='red', linewidth=3.5) ) ax.text(bbox[0], bbox[1] - 2, '&#123;:s&#125; &#123;:.3f&#125;'.format(class_name, score), bbox=dict(facecolor='blue', alpha=0.5), fontsize=14, color='white') ax.set_title(('&#123;&#125; detections with ' 'p(&#123;&#125; | box) &gt;= &#123;:.1f&#125;').format(class_name, class_name,thresh), fontsize=14) dets_ann = ann['coord'] for i in range(len(dets_ann)): ellipse_ann = dets_ann[i, :5] #(r_vertical, r_horizontal, theta, c_x, c_y) ellipse = Ellipse(xy=(ellipse_ann[3], ellipse_ann[4]), width=ellipse_ann[0]*2, height=ellipse_ann[1]*2, angle=np.degrees(ellipse_ann[2]), edgecolor='r', fc='None', lw=2) ax.add_patch(ellipse) plt.axis('off') plt.tight_layout() plt.draw() plt.show() det_name = [] # detection file nametime_name = [] # detection timeann_name = [] # annotation file namefor i in range(10): det_name.append('FDDB-det-fold-&#123;:0&gt;2&#125;.txt'.format(i+1)) time_name.append('FDDB-time-fold-&#123;:0&gt;2&#125;.txt'.format(i+1)) ann_name.append('../FDDB-folds/FDDB-fold-&#123;:0&gt;2&#125;-ellipseList.txt'.format(i+1))res = []ann = []for i in range(10): res_det = getRes_det(det_name[i]) res_time = getRes_time(res_det, time_name[i]) res.extend(res_time) ann_det = getRes_det(ann_name[i]) ann.extend(ann_det) # 显示第 1000 幅图的效果temp = res[1000]temp_ann = ann[1000]showRes(temp, temp_ann)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[感知机]]></title>
      <url>%2F2017%2F04%2F05%2Fperceptron%2F</url>
      <content type="text"><![CDATA[空间中有两类线性可分的样本，感知机算法希望找出一条直线（超平面），恰好把这两类点分开。感知机原理很简单，这里研究二维平面的情况，不失一般性。 算法样本集为 ${x^n}$，其中第 $t$ 个样本点为 $(x^t_1, x^t_2)$，标签为 $y^t$。分类直线用 $\theta = (\theta_0, \theta_1, \theta_2)$ 表示。该直线方程为：$$\theta_0 + \theta_1\cdot x_1 + \theta_2\cdot x_2 = 0$$ 为了能用矩阵乘法表示，扩充 $x$，令其第 0 维值为1，即$$\theta^T\cdot x = [\theta_0, \theta_1, \theta_2]\cdot\left[\begin{matrix}1 \\x_1 \\x_2\end{matrix}\right]$$ 约定：如果点 $(x^t_1, x^t_2)$ 在直线上方，则 $\theta^T\cdot x$ 大于0，对应的标签 $y^t=+1$，反之 $\theta^T\cdot x$ 小于0，$y^t=-1$。 算法很简单，初始化 $\theta$ 为 0。用 $\theta$ 来分类样本，每遇到一个分类结果与标签不符的样本，则将 $\theta$ 加上该样本向量乘以它的标签（$\theta = \theta + y^t\cdot[1, x_1, x_2]^T$）。原理如下：分类错的情况有两种： $\theta^T\cdot x^t&lt;0$ 但 $y^t = 1$ $\theta^T\cdot x^t&gt;0$ 但 $y^t=-1$ 站在向量点乘的角度，第一种情况说明 $\theta$ 与 $x^t$ 的夹角过大，优化目标是减小 $\theta$ 与 $x$ 的夹角，第二种情况则说明 $\theta$ 与 $x^t$ 的夹角过小，优化目标是增大 $\theta$ 与 $x$。针对这两种情况，如果分别用 $\theta$ 加上或减去误分点 $x^t$，则可以减小或增大 $\theta$ 与 $x^t$ 的夹角。因此可以采用 $\theta = \theta + y^t\cdot[1, x_1, x_2]^T$ 来更新 $\theta$。 对应的算法如下图所示： 收敛性证明如果两类样本线性可分，那么一定存在 $$\left| \theta^* \right| = 1$$ 使得对任意 $t=1,…,n$ $$y^t\cdot(\theta^{*T}\cdot x^t) \geq \gamma$$ 对于有限个样本，总能找到一个 $R$ 使得对任意 $t=1,…,n$ 有 $$\left| x^t \right| \leq R$$ 假设第 $k$ 次更新所使用的样本为 $x^t$，根据更新规则： $$\begin{align}\theta^{k+1}\cdot\theta^* &amp;= (\theta^k+y^t\cdot x^t)^T\cdot \theta^* \\&amp;= \theta^{kT}\cdot\theta^*+y^t\cdot \theta^{*T}\cdot x^t \\&amp;\geq \theta^{kT}\cdot\theta^* + \gamma\end{align}$$ 将 $\theta^1$ 初始化为 0 向量，则有： $$\theta^{k+1}\cdot\theta^* \geq k\gamma$$ 而两个向量的点乘一定小于等于它们模的乘积，且已知 $\theta^*$ 的模为1，故： $$\left| \theta^{k+1} \right| \geq k\gamma$$ 接下来研究 $\left|\theta^{k+1}\right|$。 $$\begin{align}\left| \theta^{k+1} \right|^2 &amp;= (\theta^k+y^t\cdot x^t)^2 \\&amp;= \left| \theta^k\right|^2+ \left|x^t\right|^2+2y^t(x^{tT}\cdot\theta^k) \\&amp;\leq \left| \theta^k\right|^2+R^2 \\&amp;\leq kR^2\end{align}$$ 因此 $\theta^{k+1}$ 同时满足：$$\left| \theta^{k+1} \right| \geq k\gamma$$ $$\left| \theta^{k+1} \right|^2 \leq kR^2$$也就是：$$k^2\gamma^2\leq kR^2$$因此$$k \leq \frac{R^2}{\gamma^2}$$ 不等号右边即为迭代次数的上限。 示例代码12345678910111213141516171819202122232425262728293031323334353637import numpy as npimport matplotlib.pyplot as pltx_1 = np.random.randn(20,2)+np.array([-2,2]) # 初始化两组可分类样本x_2 = np.random.randn(20,2)+np.array([2,-2])fig,ax = plt.subplots(figsize=(6,6))ax.scatter(x_1[:,0],x_1[:,1],marker='o',s=50, )ax.scatter(x_2[:,0],x_2[:,1], marker='x', s=50) # w = np.random.rand(3)w = np.array([0, 0, 0]) # 初始化分类平面x_1 = np.hstack((np.ones((x_1.shape[0],1)),x_1)) # 扩充样本维度 x_2 = np.hstack((np.ones((x_2.shape[0],1)),x_2)) y_1 = np.ones((x_1.shape[0],1)) # 初始化标签y_2 = -np.ones((x_2.shape[0],1))x = np.vstack((x_1, x_2)) # 两类样本组合在一起y = np.vstack((y_1, y_2))shuffle_ind = np.arange(x_1.shape[0]+x_2.shape[0]) # 打乱样本顺序np.random.shuffle(shuffle_ind)x = x[shuffle_ind]y = y[shuffle_ind]flag = 1count = 0while flag: flag = 0 for i in range(x.shape[0]): if (np.sum(w*x[i])*y[i]&lt;=0): w = w+y[i]*x[i] flag = 1 count += 1a = np.linspace(-5,5,100)b = -(w[1]*a+w[0])/w[2]ax.plot(a,b)fig.show() 参考资料Convergence Proof for the Perceptron Algorithm]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[旋转矩阵]]></title>
      <url>%2F2017%2F04%2F01%2Frotation%2F</url>
      <content type="text"><![CDATA[问题简述本文研究几何变换矩阵，以及在 OpenCV 中实现图像的旋转、放缩。 推导首先将问题简化：在二维坐标系中，将某点绕坐标原点旋转一定的角度，已知旋转前的坐标 $(x_0,y_0)$ 和旋转角 $\theta$，求旋转后的坐标 $(x,y)$。 如上图所示，旋转前后的目标点都用蓝色箭头表示，旋转前其坐标为 $(x, y)$ （推导过程为了区分，采用 $(x_0, y_0)$ ）。旋转前坐标系用黑色实线表示，为了辅助推导，图中作出了旋转后的坐标系，用红色虚线表示（可以想象成红色坐标系固连在点上，随着点一起旋转）。 原坐标系基底为:$$\vec b_1 = \left(\begin{matrix}1 \\0\end{matrix}\right) \qquad\vec b_2 = \left(\begin{matrix}0 \\1\end{matrix}\right)$$ 原坐标表示成基底相加的形式：$$\left(\begin{matrix}x_0 \\y_0\end{matrix}\right)=x_0\cdot\vec b_1+y_0\cdot\vec b_2 =x_0\cdot\left(\begin{matrix}1 \\0\end{matrix}\right)+y_0\cdot\left(\begin{matrix}0 \\1\end{matrix}\right)$$ 从图中可以看到，旋转后的点与红色坐标系的相对位置没有改变，仍然等于 $x_0$ 个横向基底加 $y_0$ 个纵向基底。因此，只要求出红色坐标系的横向基底和纵向基底，即可获得旋转后的点在原坐标系中的坐标。根据三角函数，很容易得到这一组新的基底：$$\vec {b_1’} = \left(\begin{matrix}cos\ \theta \\sin\ \theta\end{matrix}\right) \qquad\vec {b_2’} = \left(\begin{matrix}-sin\ \theta \\cos\ \theta\end{matrix}\right)$$因此，旋转后的点在原坐标系中的坐标为：$$\left(\begin{matrix}x \\y\end{matrix}\right)=x_0\cdot\vec {b_1’}+y_0\cdot\vec {b_2’} =x_0\cdot\left(\begin{matrix}cos\ \theta \\sin\ \theta\end{matrix}\right)+y_0\cdot\left(\begin{matrix}-sin\ \theta \\cos\ \theta\end{matrix}\right)$$ 转换成矩阵乘积的形式为：$$\left(\begin{matrix}x \\y\end{matrix}\right) = \left[\begin{matrix}cos\ \theta &amp; -sin\ \theta \\sin\ \theta &amp; cos\ \theta\end{matrix}\right]\cdot\left(\begin{matrix}x_0 \\y_0\end{matrix}\right)$$ OpenCV 旋转图片若要在 OpenCV 中实现图片旋转，首先需要通过调用 cv2.getRotationMatrix2D 生成旋转矩阵，事实上，该矩阵同时涵盖了以任意点为中心的旋转（上一部分仅仅考虑了旋转中心为坐标原点的情况）+放缩变换。 12345img = cv2.imread('messi5.jpg',0)rows,cols = img.shapeM = cv2.getRotationMatrix2D((cols/2,rows/2),90,1)dst = cv2.warpAffine(img,M,(cols,rows)) cv2.getRotationMatrix2D 传入的参数分别为：旋转中心$(x_0, y_0)$，旋转角度 $\theta$（非弧度制），放缩量 $scale$。生成如下所示的矩阵：$$\left[\begin{matrix}\alpha &amp; \beta &amp; (1-\alpha)\cdot x_0-\beta y_0 \\-\beta &amp; \alpha &amp; \beta x_0+(1-\alpha)\cdot y_0\end{matrix}\right]$$ 其中：$$\alpha = scale\cdot cos\theta \\\beta = scale\cdot sin\theta$$ 分析上述矩阵中的元素，可以看出，$\alpha$、$\beta$ 是负责旋转的量。但是它的负号位置与第一部分推导的不同，这是因为图像坐标系不是标准坐标系，图像坐标系中规定图像左上角为坐标原点，水平向右为 $x$ 轴正方向，竖直向下为 $y$ 轴正方向。那么，OpenCV 又是如何把放缩和以任意点为中心的旋转整合到同一矩阵的呢？ 其实可以把上述的复杂变换分解成几个简单变换：平移、放缩、旋转。 平移旋转中心不是坐标原点的情况（i.e $(x_0, y_0)$），可以先将坐标原点临时平移到指定的旋转中心，然后进行旋转变换，再将坐标原点平移回去。可以想象成月球绕着地球转，先求出月球旋转某个角度后相对于地球的坐标，再根据地球的位置，求出月球相对于太阳的坐标。 平移矩阵为：$$T =\left[\begin{matrix}1 &amp; 0 &amp; -x_0 \\0 &amp; 1 &amp; -y_0 \\0 &amp; 0 &amp; 1\end{matrix}\right]$$最后一行的目的是辅助计算，输入的坐标也增加一个维度，增加的维度上值始终为 1，例如 $[x, y]^T$ 变为 $[x, y, 1]^T$。 平移加放缩坐标原点上的放缩矩阵为： $$S =\left[\begin{matrix}scale &amp; 0 &amp; 0 \\0 &amp; scale &amp; 0 \\0 &amp; 0 &amp; 1\end{matrix}\right]$$ 若放缩中心不是坐标原点，则先将坐标系平移到放缩中心，放缩后再移回原点。这个过程可以用矩阵乘法表示： $$T’ST =\left[\begin{matrix}1 &amp; 0 &amp; x_0 \\0 &amp; 1 &amp; y_0 \\0 &amp; 0 &amp; 1\end{matrix}\right]\cdot\left[\begin{matrix}scale &amp; 0 &amp; 0 \\0 &amp; scale &amp; 0 \\0 &amp; 0 &amp; 1\end{matrix}\right]\cdot\left[\begin{matrix}1 &amp; 0 &amp; -x_0 \\0 &amp; 1 &amp; -y_0 \\0 &amp; 0 &amp; 1\end{matrix}\right]$$ 平移加放缩加旋转在上一节的过程中，移回坐标原点前，先进行一次旋转操作，就得到了平移加放缩加旋转的变换矩阵，也就是 OpenCV 中的变换矩阵。 图像坐标系中以坐标原点为中心的旋转矩阵为： $$R =\left[\begin{matrix}cos\ \theta &amp; sin\ \theta &amp; 0 \\-sin\ \theta &amp; cos\ \theta &amp; 0 \\0 &amp; 0 &amp; 1\end{matrix}\right]$$ 因此，总的旋转矩阵为： $$T’RST =\left[\begin{matrix}1 &amp; 0 &amp; x_0 \\0 &amp; 1 &amp; y_0 \\0 &amp; 0 &amp; 1\end{matrix}\right]\cdot\left[\begin{matrix}cos\ \theta &amp; sin\ \theta &amp; 0 \\-sin\ \theta &amp; cos\ \theta &amp; 0 \\0 &amp; 0 &amp; 1\end{matrix}\right]\cdot\left[\begin{matrix}scale &amp; 0 &amp; 0 \\0 &amp; scale &amp; 0 \\0 &amp; 0 &amp; 1\end{matrix}\right]\cdot\left[\begin{matrix}1 &amp; 0 &amp; -x_0 \\0 &amp; 1 &amp; -y_0 \\0 &amp; 0 &amp; 1\end{matrix}\right]$$ 也就是： $$\left[\begin{matrix}scale\cdot cos\ \theta &amp; scale\cdot sin\ \theta &amp; x_0\cdot(1-scale\cdot cos\ \theta)-y_0\cdot scale\cdot sin\ \theta \\-scale\cdot sin\ \theta &amp; scale\cdot cos\ \theta &amp; y_0\cdot(1-scale\cdot cos\ \theta)+x_0\cdot scale\cdot sin\ \theta \\0 &amp; 0 &amp; 1\end{matrix}\right]$$ 令 $$\alpha = scale\cdot cos\theta \\\beta = scale\cdot sin\theta$$ 得到$$\left[\begin{matrix}\alpha &amp; \beta &amp; (1-\alpha)\cdot x_0-\beta y_0 \\-\beta &amp; \alpha &amp; \beta x_0+(1-\alpha)\cdot y_0 \\0 &amp; 0 &amp; 1\end{matrix}\right]$$前两行与 OpenCV 文档中完全相同。 代码 1可以直接调用 OpenCV 的函数对图片进行旋转，如下代码实现了将某幅图片绕其几何中心逆时针旋转 90°，并保持原尺寸。 1234567891011import cv2import matplotlib.pyplot as pltimg = cv2.imread('cat.jpg')rows,cols = img.shape[0:2] # 图像的尺寸M = cv2.getRotationMatrix2D((cols/2,rows/2),90,1) # 注意几何中心的坐标与尺寸的关系，横坐标对应列，纵坐标对应行dst = cv2.warpAffine(img,M,(rows,cols)) # 注意目标图像的尺寸，这里 rows 和 cols 代表的是新图像在横、纵坐标方向的长度，不是原图中的行、列 # 显示图片dst = dst[:,:,::-1] # matplotlib 通道顺序为 RGB 而 OpenCV 通道顺序为 BGR 故在这里调整通道顺序plt.imshow(dst)plt.show() 代码 2然而，当利用上述代码旋转矩形图像时，会出现旋转后的图片有黑边的现象。这是由于旋转后的图像中心与旋转前的图像中心在旋转前的图像坐标系中不重合的缘故。具体来讲，旋转前的图像中心坐标为(cols/2, rows/2)，以90°旋转为例，旋转后的图像中心坐标为(rows/2, cols/2)。因此需要再乘以一个平移矩阵，横向平移量为 rows/2-cols/2，纵向平移量为 cols/2-rows/2。由于矩阵乘法很耗运算资源，而乘以平移矩阵的结果一目了然，因此在代码实现过程中，直接修改旋转矩阵第一行和第二行第三列的元素值即可。 下面的代码适用于任意角度的旋转。 123456789101112131415161718192021222324252627282930313233343536import cv2import matplotlib.pyplot as pltimport numpy as npI = cv2.imread('cat.jpeg')height, width = I.shape[0:2]center = (width/2, height/2)theta = np.pi*1.7scale = 1rot_mat = cv2.getRotationMatrix2D(center, np.degrees(theta), scale) # rot_mat = np.vstack((rot_mat, [0,0,1]))new_height = height*np.abs(np.cos(theta))+width*np.abs(np.sin(theta))new_width = height*np.abs(np.sin(theta))+width*np.abs(np.cos(theta))new_center = (new_width/2, new_height/2)dx, dy = (new_center[0]-center[0], new_center[1]-center[1]) #trans_mat = np.eye(3) #trans_mat[0,2] = dx #trans_mat[1,2] = dy #affine_mat = np.dot(trans_mat, rot_mat)affine_mat = rot_mat[0:2,:]affine_mat[0,2] += dxaffine_mat[1,2] += dyJ = cv2.warpAffine(I, affine_mat, (int(new_width), int(new_height)))plt.imshow(I)plt.show()plt.imshow(J)plt.show() 参考资料Geometric Transformations of Images]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cython 入门教程]]></title>
      <url>%2F2017%2F03%2F11%2Fcython-tuto%2F</url>
      <content type="text"><![CDATA[用 Cython 加快 Python 循环速度本文翻译自该博客Cython 是 Python 语言到 C 语言的翻译器, 它能让你利用 Python 类似的语法达到接近 C 语言的运行速度。 本文介绍了如何用 Cython 来对单一包含紧凑循环（”tight loops”）的 Python 函数进行加速。在后续的文章中将会介绍关于 Cython 更复杂的应用，例如包含各种函数和类的情况。 什么时候该使用 Cython你可以选择很多种方案来提升自己 Python 代码的运行速度，各种方案的具体对比请参考 quantecon。当然，你也可以选择另一种更快的语言来实现自己的项目，比如 Julia 或者干脆横下心来用 C 语言。 Cython 静态编译并不是什么前沿技术，这是一项很成熟而且有良好文档支持的技术，能够应付复杂的大型项目。很多 Python 科学计算库后台采用了 Cython 代码，例如 pandas 和 scikit-learn。 例子我们这里的例程实现了一种径向基函数的近似计算。 $$\hat{Y}_i = \sum_{j=1}^N \beta_j e^{(-(\theta\left\Vert X_i-X_j\right\Vert)^2)}$$ 这个函数的输入为 $N$ 行 $D$ 列的数组 $X$，长度为 $N$ 的参数数组 $\beta$ 以及一个带宽(‘bandwidth’) 参数 $\theta$，返回长度为 $N$ 的数组 $\hat{Y}$。 Python 循环下面是对上述函数的一个最初版本的 Python 实现。 1234567891011121314151617from math import expimport numpy as npdef rbf_network(X, beta, theta): N = X.shape[0] D = X.shape[1] Y = np.zeros(N) for i in range(N): for j in range(N): r = 0 for d in range(D): r += (X[j,d]-X[i,d])**2 r = r**0.5 Y[i] += beta[j]*exp(-(r*theta)**2) return Y 接下来生成一些数据： 123456import numpy as npD = 5N = 1000X = np.array([np.random.rand(D) for d in range(N)])beta = np.random.rand(N)theta = 10 在 IPython 中测算运行时间 1%timeit rbf_network(X, beta, theta) # 5.15 s per loop 1 loop, best of 3: 5.46 s per loop 果然这些 Python 循环很慢！ scipy.interpolate.Rbf这种情况下，我们幸运地找到了基于 numpy 的 RBF 实现。 12345from scipy.interpolate import Rbfrbf = Rbf(X[:,0],X[:,1],X[:,2],X[:,3],X[:,4], np.random.rand(N))Xtuple = tuple([X[:,i] for i in range(D)])%timeit rbf(Xtuple) #336 ms per loop 1 loop, best of 3: 342 ms per loop 现在好多了！但是如果我们想把程序运行得快一点，但却找不到可用的函数库呢？ Cython我们在文件 fastloop.pyx 中实现 Cython 版本的代码，其内容如下 12345678910111213141516171819from math import expimport numpy as npdef rbf_network(double[:, :] X, double[:] beta, double theta): cdef int N = X.shape[0] cdef int D = X.shape[1] cdef double[:] Y = np.zeros(N) cdef int i, j, d cdef double r = 0 for i in range(N): for j in range(N): r = 0 for d in range(D): r += (X[j, d]-X[i, d])**2 r = r**0.5 Y[i] += beta[j] * exp(-(r*theta)**2) return Y 目前为止我们做的工作仅仅是在变量名前面增加了一些类型声明。对局部变量，我们采用 cdef 关键字。对 array 数组，我们采用 ‘memoryviews’ 来接受 numpy 数组输入。 值得注意的是，在 *.pyx 文件中，你没有必要对变量进行声明，任何没有声明类型的变量都会留在 Python 中，而不会被翻译为 C 类型。 为了编译上面的 fastloop.pyx 文件，我们需要写一个 setup.py 脚本，内容如下所示 1234from distutils.core import setupfrom Cython.Build import cythonizesetup(name='fastloop', ext_modules=cythonize('fastloop.pyx'),) 然后，我们在 terminal 中对 fastloop.pyx 进行编译，命令如下： 1python setup.py build_ext --inplace 这个命令会生成 C 代码文件 fastloop.c 和一个编译好的 Python 库文件 fastloop.so。 然后我们对这个库文件进行测试 12from fastloop import rbf_network%timeit rbf_network(X, beta, theta) # 87.3 ms per loop 10 loops, best of 3: 84 ms per loop 果然快了很多，但是我们还有提升空间。Cython 中有很多提升性能的小技巧。下面将介绍第一个，如果我们在 terminal 中输入 1cython fastloop.pyx -a 我们将生成一个 fastloop.html 文件，我们在浏览器中打开它。如下图所示 黄色高亮的语句仍然在使用 Python 运行，导致程序变慢。我们优化的目标是避免黄色高亮语句，尤其是在循环中。 我们的第一个问题是依旧在使用 Python 版本的指数函数，应该把它替换成 C 版本的。 math.h 中的大多数函数都包含在了 Cython 的 libc 库中，所以只需要用下面的语句替换 from math import exp 1from libc.math import exp 接下来我们需要增加一些编译指令（compiler directives），最简单的方法是将下面的这行增加到 fastloop.pyx 文件头部 1#cython: boundscheck=False, wraparound=False, nonecheck=False 通过把这些检测关掉，一旦程序出错，你只能得到段错误的提示，而不是像 python 中那种特别详细的信息，因此，最好是先把代码的错误排除干净，再添加该行。 接下来我们可以考虑修改编译器参数（这些属于 C 语言的技巧）。当我们用 gcc 时，最重要的编译选项是 -ffast-math。在我有限的经验中，这可以大大提高程序速度，而不损失可靠性。为了实现这个改变，我们需要修改 setup.py 文件。 12345678910111213from distutils.core import setupfrom distutils.extension import Extensionfrom Cython.Distutils import build_extext_modules=[ Extension("fastloop", ["fastloop.pyx"], libraries=["m"], extra_compile_args=["-ffast-math"])] setup( name='fastloop', cmdclass=&#123;"build_ext": build_ext&#125;, ext_modules=ext_modules) 现在再次运行 cython fastloop.pyx -a，我们看到循环中的语句已经不是用 Python 运行的了： 循环之外的黄色语句在这里对程序运行速度没有太大影响（如果需要在循环中多次调用这个函数，那么将会影响速度）。 我们可以重新编译程序，并测速 12from fastloop import rbf_network %timeit rbf_network(X, beta, theta) # 21.7 ms per loop 10 loops, best of 3: 22.4 ms per loop 本文为 jupyter notebook 转换成 markdown 格式，也可以通过 nbviewer 将 .ipynb 文件转成网页文件。然后再把 &lt;iframe src=&quot;your_URL&quot; width=&quot;700&quot; height=&quot;400&quot;&gt;&lt;/iframe&gt; 插入文章需要引用的部分。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo 基本操作]]></title>
      <url>%2F2017%2F03%2F05%2F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[本文参考了官网文档，主要介绍了 Hexo 文章的写作、生成、部署，以及写作过程中涉及的插入引用、码块、图片、Latex 公式，以及在主页上只局部显示部分文章内容的设置。 写作创建新文章，在根目录下输入：1$ hexo new [layout] &lt;title&gt; 其中的 [layout] 默认为 post，可以通过修改 _config.yml 中的 default_layout 设置默认布局。 布局（Layout）Hexo 有三种默认的布局：post、page 和 draft ，它们分别保存在本地不同的路径，二自定义的其它布局和 post 布局都保存在 source/_posts 文件夹中。 布局 路径 post source/_posts page source draft source/_drafts 如果不想文章的格式被处理，则可以在 Front-Matter 中设置 layout: false。这时网页只会显示纯文本，不会加载任何模板，但是这时的网页也并不会保留 markdown 的标记符号，而是将其转为 html 的标签。 文件名称创建新文件时，通过命令：hexo new filename，这时在 source/_posts 中会出现文件 filename.md，并且在文件头部初始化了 Front-Matter。但是为了便于管理文件，希望在文件名前面加入创建日期，保存为日期+文件名.md，例如 2017-03-05-filename.md，则需要修改 hexo 根目录下的 _config.yml 文件，将其中的 new_post_name 字段参数设置为: :year-:month-:day-:title.md，这样就可以达到预期效果了。其中 :month 和 :day 可以替换为 :i_month 和 :i_day，使得建立的文件名月份和日期前面没有0（七号的 07 替换为 7）。 草稿上文中提到了 Hexo 的 draft 布局，可以通过命令 hexo new draft filename 建立这种布局的文件，它默认保存在 source/_drafts 文件夹，可以通过 publish 命令将其移动到 source/_posts 文件夹中，该命令中也可以通过 layout 来指定布局。1$ hexo publish [layout] &lt;title&gt; 保存为草稿的文章不会在网页中显示。 Front-matterFront-matter hexo new filename 命令生成的文件中自带的配置信息，位于文件开头，用于制定当前文稿的样式。例如本文的 Front-matter 为：12345678---title: hexo 基本操作date: 2017-03-05 15:11:26tags:- hexo 命令categories: - 网站配置相关--- 除了上面的 title、date、tags、categories 之外，还可以添加别的字段，例如 字段 作用 comments: true 允许或禁止该文章的评论，其值默认为 true 因此可以不指定，如果设为 false，则禁止游客对该文进行评论 updated: 日期 用于设置文章更新日期 permalink: :year/:month/:day/:title/ 用于生成访问链接的格式，默认为 https://charlesnord.github.io/2016/05/06/your_title/ 类似的，可以改为 :year/:month/:day/:title.html 更搜索引擎友好 分类和标签只有 post 布局的文章支持分类和标签。分类和标签分别对应 Front-Matter 中的 categories: 和 tags:字段，其书写格式如上一节所示。分类和标签不同，分类有顺序性和层次性，而标签不分顺序和层次。 如果 categories: 下指定了多个类别，那么这些类别是包含关系，例如：123categories:- Diary- Life 其中 Life 是 Diary 的子分类，而不是并列分类。因此 categories: 最好只指定一个类别，而 tags: 可以指定多个标签，每个标签以 - 开头，在 tag: 下单独占一行。 标签插件（Tag Plugins）这里的标签插件不是上文的标签，它们用于在文章中快速插入特定内容的插件，例如图片、代码块等。这里的语法和 markdown 不同，是 Hexo 特有的语法（也可以用 markdown 语法）。 引用块在文章中插入引言，可包含作者、来源和标题。别号： quote123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote%&#125; 样例 没有提供参数，则只输出普通的 blockquote123456&#123;% blockquote %&#125;我说：“妖妖，你看那水银灯的灯光像什么？大团的蒲公英浮在街道的河流口，吞吐着柔软的针一样的光。”妖妖说：“好，那么我们在人行道上走呢？这昏黄的路灯呢？”我抬头看看路灯，它把昏黄的灯光隔着蒙蒙的雾气一直投向地面。我说：“我们好象在池塘的水底。从一个月亮走向另一个月亮。”妖妖忽然大惊小怪地叫起来：“陈辉，你是诗人呢！”&#123;% endblockquote %&#125; 我说：“妖妖，你看那水银灯的灯光像什么？大团的蒲公英浮在街道的河流口，吞吐着柔软的针一样的光。”妖妖说：“好，那么我们在人行道上走呢？这昏黄的路灯呢？”我抬头看看路灯，它把昏黄的灯光隔着蒙蒙的雾气一直投向地面。我说：“我们好象在池塘的水底。从一个月亮走向另一个月亮。”妖妖忽然大惊小怪地叫起来：“陈辉，你是诗人呢！” 引用书上的句子123456&#123;% blockquote 王小波，绿毛水怪 %&#125;我说：“妖妖，你看那水银灯的灯光像什么？大团的蒲公英浮在街道的河流口，吞吐着柔软的针一样的光。”妖妖说：“好，那么我们在人行道上走呢？这昏黄的路灯呢？”我抬头看看路灯，它把昏黄的灯光隔着蒙蒙的雾气一直投向地面。我说：“我们好象在池塘的水底。从一个月亮走向另一个月亮。”妖妖忽然大惊小怪地叫起来：“陈辉，你是诗人呢！”&#123;% endblockquote %&#125; 我说：“妖妖，你看那水银灯的灯光像什么？大团的蒲公英浮在街道的河流口，吞吐着柔软的针一样的光。”妖妖说：“好，那么我们在人行道上走呢？这昏黄的路灯呢？”我抬头看看路灯，它把昏黄的灯光隔着蒙蒙的雾气一直投向地面。我说：“我们好象在池塘的水底。从一个月亮走向另一个月亮。”妖妖忽然大惊小怪地叫起来：“陈辉，你是诗人呢！” 王小波，绿毛水怪 引用网络上的文章 123456&#123;% blockquote 王小波，绿毛水怪 %&#125;我说：“妖妖，你看那水银灯的灯光像什么？大团的蒲公英浮在街道的河流口，吞吐着柔软的针一样的光。”妖妖说：“好，那么我们在人行道上走呢？这昏黄的路灯呢？”我抬头看看路灯，它把昏黄的灯光隔着蒙蒙的雾气一直投向地面。我说：“我们好象在池塘的水底。从一个月亮走向另一个月亮。”妖妖忽然大惊小怪地叫起来：“陈辉，你是诗人呢！”&#123;% endblockquote %&#125; 我说：“妖妖，你看那水银灯的灯光像什么？大团的蒲公英浮在街道的河流口，吞吐着柔软的针一样的光。”妖妖说：“好，那么我们在人行道上走呢？这昏黄的路灯呢？”我抬头看看路灯，它把昏黄的灯光隔着蒙蒙的雾气一直投向地面。我说：“我们好象在池塘的水底。从一个月亮走向另一个月亮。”妖妖忽然大惊小怪地叫起来：“陈辉，你是诗人呢！” 王小波绿毛水怪 代码块别号：code123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 反引号代码块：1```[language] [title] [url] [link text] code snippet``` 样例 Hexo 代码块12345&#123;% codeblock lang:python %&#125;x = 1y = 2print x + y&#123;% endcodeblock%&#125; 123x = 1y = 2print x + y 反引号代码块12345```pythonx = 1y = 2print x + y``` 123x = 1y = 2print x + y 更多的标签插件（Tag Plugins）请参考官方文档 Latex 公式Latex 公式可以用两种区块进行包裹，用于提示进行 latex 渲染，分别是 \\[ math equation \\] 和 $$ math equation $$。例子：1234567891011121314\\[\begin&#123;aligned&#125;\dot&#123;x&#125; &amp; = \sigma(y-x) \\\\dot&#123;y&#125; &amp; = \rho x - y - xz \\\\dot&#123;z&#125; &amp; = -\beta z + xy\end&#123;aligned&#125; \\]$$\frac&#123;\partial u&#125;&#123;\partial t&#125; = h^2 \left( \frac&#123;\partial^2 u&#125;&#123;\partial x^2&#125; + \frac&#123;\partial^2 u&#125;&#123;\partial y^2&#125; + \frac&#123;\partial^2 u&#125;&#123;\partial z^2&#125;\right)$$$$\sum_1^n x^2 = 1$$ 效果：\[\begin{aligned}\dot{x} &amp; = \sigma(y-x) \\\dot{y} &amp; = \rho x - y - xz \\\dot{z} &amp; = -\beta z + xy\end{aligned}\] $$\frac{\partial u}{\partial t} = h^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right)$$ $$\sum_1^n x^2 = 1$$ 文章长度过长Hexo 默认在主页上全文显示所有文章，为了能在主页只显示文章的简介，可以在文章合适的位置添加如下行：1&lt;!--more--&gt; 这样，在主页上只会显示该行以前的内容，以后的内容被折叠。因此，每篇文章开头最好写一个用于在主页显示的简介，然后在简介下方添加上面的行。 资源文件夹资源文件夹是指存储文章中图片、CSS、JS 等文件的文件夹。如果 Hexo 项目中只有少量图片，可以把它们放在 source/images 文件夹中。然后用 markdown 语法 ![](/images/image.jpg) 在文章中引用它们。 文章资源文件夹正常情况下建议采用文章资源文件夹，对每篇文章的资源进行分别存储。首先需要修改 _config.yml 中的 post_asset_folder 选项设置为 true 来打开。打开这个选项后，Hexo 会每次在用户通过 hexo new filename 新建的文章建立与文章同名的文件夹，用来存储该文章需要的资源。 相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在主页或者 archieve 页显示不正确，因此建议采用 hexo 的标签插件来对其进行引用。 123&#123;% asset_img slug [title] %&#125;&#123;% asset_path slug %&#125;&#123;% asset_link slug [title] %&#125; 建议采用插件引用图片，例如，在与文章同名的资源文件夹下放置 example.jpg 图片，然后，在文章中通过下面的语句进行引用。1&#123;% asset_img example.jpg This is an example %&#125; 服务器编辑完文档后，通过在 hexo 根目录执行命令 hexo server（hexo s） 来将项目部署到本地服务器上，部署端口默认为 4000。此时，在本机输入 http://localhost:4000 即可访问网站。服务器启动期间，Hexo 会监视文件变动并自动更新，因此每次改动源文件后无需重新生成、重启服务器才可以看到变化，直接刷新网页即可。 如果想修改默认端口，例如改为 5000 ，可以运行命令 hexo server -p 5000。 除了在主机上通过 http://localhost:4000 访问，在局域网下，连接同一个路由器的设备都可以访问该网站，前提是知道该网站服务器的局域网 ip 地址。在 mac 上，可以通过: 系统偏好设置 -&gt; 网络 查看本机的局域网 ip。例如本人电脑目前的局域网 ip 地址为 192.168.1.104，在本人手机浏览器输入：http://192.168.1.104:4000，即可访问本网站。至于如何通过外网访问，请阅读这一系列的 Hexo 搭建教程。 生成文件如果想将网站部署到 github 上，则需要将本地的工程生成为静态文件，在 Hexo 根目录下执行命令：hexo generate（hexo g）。生成后执行 hexo deploy 将其部署到 github。对于部署到 github 的静态文件，本地修改源文件不能实时显示到网站上，因此每次做出修改后，想要观察效果，可以用上节的命令将其部署到本地服务器，确认没有问题了，再用本节的命令生成静态文件，并部署到 github。 监视文件变动如果要重新生成所有文件，则需要执行命令 hexo clean，hexo g，但是这样往往生成的时间会很长。也可以采用1hexo generate --watch 实时地生成静态文件，执行上述命令后，Hexo 能够通过对比文件的 SHA1 checksum 监视文件的实时变动，只对变动的文件生成静态文件。 生成后部署部署到 github 采用 hexo deploy 命令，也可以任意执行下面的两条组合命令中的一条，让 Hexo 在生成完成后自动部署网站，两条命令是等价的。12hexo generate --deployhexo deploy --generate 或者简写为： hexo g -dhexo d -g 至此，Hexo 的基本操作就介绍完了，完整介绍请查阅官网文档]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F05%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start本文是 hexo 文档的一部分，记录了 hexo 的几个基本命令，通过它们，就可以清空之前的编译、编译新的文件、在本地服务器浏览网站，最终将其上传至 github。在此记录，便于查阅。 Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment hexo 配置网站全面教程这个教程十分有价值，涵盖了 hexo 的基本安装，以及各种复杂配置。分为好几部分，这里索引的是最关键的第三部分，前两部分在其网页内部有链接可以找到。 常见问题也列举了一些使用过程中常见问题的解决方案。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[项目已被 OSX 使用，不能打开]]></title>
      <url>%2F2017%2F03%2F05%2Fosx-%E5%8D%A0%E7%94%A8%2F</url>
      <content type="text"><![CDATA[问题描述windows NTFS 格式的移动硬盘经常出现文件不能打开的情况，文件的颜色变浅，双击打开没有反应，右键打开方式，出现提示：项目 “xxx” 已被 OSX 使用，不能打开。如下图所示： 解决方案解决方案分为两步： 安装 Mounty正常的 NTFS 格式硬盘是无法从 mac 向其拷贝文件的，因为 mac 系统对其实只读权限，无法修改硬盘内部文件。而该软件的作用是将 NTFS 格式的移动硬盘挂载到 mac 系统上，使系统获得对硬盘的读写权限，便于我们修改硬盘内部的文件。 修改文件信息安装好 Mounty 后，就可以将硬盘挂载到系统上，并使系统获得对其的读写权限了。 打开 terminal，输入 ls -l 文件名 查看文件权限，可以先输入ls -l空格，然后直接将硬盘中的文件拖拽到 terminal 的该行尾部，回车。发现其权限为 -rwxr-xr-x@ 最末尾的 @ 即表示该文件被 mac osx 占用，如下图所示： terminal 中输入 xattr -c 文件名 解除 osx 对文件的占用，此时重复上一步，将不会在权限里面出现@。命令行如下图所示：执行完这个命令后，文件就能正常打开了。这个方法需要安装 Mounty，对于不想安装 Mounty 的，可以通过命令行将硬盘挂载为读写模式，具体方法见下一部分。 挂载硬盘为读写模式分为以下几步： 插入硬盘后，查看 /Volumes 下的文件，此时应该能发现两个硬盘，一个是系统的硬盘，另一个是插入的外接硬盘 输入 diskutil info /Volumes/硬盘名 查看 硬盘的 Device Node。我的是 /dev/disk2s1 (以上两步也可以用 diskutil list 查看，前提是能分辨出哪个是系统硬盘，哪个是刚插上的硬盘) 弹出该硬盘 hdiutil eject /Volumes/硬盘名，此时终端会输出 &quot;disk2&quot; unmounted 以及 &quot;disk2&quot; ejected 在 /Volumes/ 下创建一个目录，稍后将硬盘文件挂载到这个目录上 sudo mkdir /Volumes/MYHD 将硬盘重新挂载到上面的目录中，并赋予读写权限sudo mount_ntfs -o rw,nobrowse /dev/disk2s1 /Volumes/MYHD/ 此时可以进入 /Volumes/MYHD 目录，查看硬盘内部文件了 通过终端进入挂载目录，输入 xattr -c 文件名 就可以解除osx 对文件的占用了，这一步和第一种方法相同。 最后将硬盘弹出 hdiutil eject /Volumes/MYHD，这个命令执行完后，MYHD 目录也会消失，省的你再删了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mou]]></title>
      <url>%2F2017%2F03%2F03%2Fmou-1%2F</url>
      <content type="text"><![CDATA[Mou 是一个很不错的 markdown 书写工具，可以实时显示效果，虽然和 hexo 的某些语法，尤其是插入图片的语法不同，但是仍然可以一用，并且它支持输入 Latex。以下部分是 Mou 的示例文档，本人在软件的 Preferences 中勾选了 Enable Math，因此又试验性地输入了几个 Latex 公式。本文主要目的是为了便于查阅语法，对于快速入门的几个重要命令，将单独写博客记录。 &gt; OverviewMou, the missing Markdown editor for web developers. SyntaxStrong and Emphasizestrong or strong ( Cmd + B ) emphasize or emphasize ( Cmd + I ) Sometimes I want a lot of text to be bold.Like, seriously, a LOT of text Blockquotes Right angle brackets &gt; are used for block quotes. Links and EmailAn email &#101;&#120;&#97;&#x6d;&#112;&#108;&#101;&#64;&#x65;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#111;&#x6d; link. Simple inline link http://chenluois.com, another inline link Smaller, one more inline link with title Resize. A reference style link. Input id, then anywhere in the doc, define the link with corresponding id: Titles ( or called tool tips ) in the links are optional. ImagesAn inline image , title is optional. A reference style image. Inline code and Block codeInline code are surround by backtick key. To create a block code: Indent each line by at least 1 tab, or 4 spaces. var Mou = exactlyTheAppIwant; Ordered ListsOrdered lists are created using “1.” + Space: Ordered list item Ordered list item Ordered list item Unordered ListsUnordered list are created using “*” + Space: Unordered list item Unordered list item Unordered list item Or using “-“ + Space: Unordered list item Unordered list item Unordered list item Hard LinebreakEnd a line with two or more spaces will create a hard linebreak, called &lt;br /&gt; in HTML. ( Control + Return )Above line ended with 2 spaces. Horizontal RulesThree or more asterisks or dashes: HeadersSetext-style: This is H1This is H2atx-style: This is H1This is H2This is H3This is H4This is H5This is H6Extra SyntaxFootnotesFootnotes work mostly like reference-style links. A footnote is made of two things: a marker in the text that will become a superscript number; a footnote definition that will be placed in a list of footnotes at the end of the document. A footnote looks like this: That’s some text with a footnote.[^1] [^1]: And that’s the footnote. StrikethroughWrap with 2 tilde characters: Strikethrough Fenced Code BlocksStart with a line containing 3 or more backticks, and ends with the first line with the same number of backticks: 123Fenced code blocks are like Stardard Markdown’s regular codeblocks, except that they’re not indented and instead rely ona start and end fence lines to delimit the code block. TablesA simple table looks like this: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell If you wish, you can add a leading and tailing pipe to each line of the table: First Header Second Header Third Header Content Cell Content Cell Content Cell Content Cell Content Cell Content Cell Specify alignment for each column by adding colons to separator lines: First Header Second Header Third Header Left Center Right Left Center Right ShortcutsView Toggle live preview: Shift + Cmd + I Toggle Words Counter: Shift + Cmd + W Toggle Transparent: Shift + Cmd + T Toggle Floating: Shift + Cmd + F Left/Right = 1/1: Cmd + 0 Left/Right = 3/1: Cmd + + Left/Right = 1/3: Cmd + - Toggle Writing orientation: Cmd + L Toggle fullscreen: Control + Cmd + F Actions Copy HTML: Option + Cmd + C Strong: Select text, Cmd + B Emphasize: Select text, Cmd + I Inline Code: Select text, Cmd + K Strikethrough: Select text, Cmd + U Link: Select text, Control + Shift + L Image: Select text, Control + Shift + I Select Word: Control + Option + W Select Line: Shift + Cmd + L Select All: Cmd + A Deselect All: Cmd + D Convert to Uppercase: Select text, Control + U Convert to Lowercase: Select text, Control + Shift + U Convert to Titlecase: Select text, Control + Option + U Convert to List: Select lines, Control + L Convert to Blockquote: Select lines, Control + Q Convert to H1: Cmd + 1 Convert to H2: Cmd + 2 Convert to H3: Cmd + 3 Convert to H4: Cmd + 4 Convert to H5: Cmd + 5 Convert to H6: Cmd + 6 Convert Spaces to Tabs: Control + [ Convert Tabs to Spaces: Control + ] Insert Current Date: Control + Shift + 1 Insert Current Time: Control + Shift + 2 Insert entity &lt;: Control + Shift + , Insert entity &gt;: Control + Shift + . Insert entity &amp;: Control + Shift + 7 Insert entity Space: Control + Shift + Space Insert Scriptogr.am Header: Control + Shift + G Shift Line Left: Select lines, Cmd + [ Shift Line Right: Select lines, Cmd + ] New Line: Cmd + Return Comment: Cmd + / Hard Linebreak: Control + Return Edit Auto complete current word: Esc Find: Cmd + F Close find bar: Esc Post Post on Scriptogr.am: Control + Shift + S Post on Tumblr: Control + Shift + T Export Export HTML: Option + Cmd + E Export PDF: Option + Cmd + P LaTex\[\begin{aligned}\dot{x} &amp; = \sigma(y-x) \\\dot{y} &amp; = \rho x - y - xz \\\dot{z} &amp; = -\beta z + xy\end{aligned}\] $$\frac{\partial u}{\partial t} = h^2 \left( \frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}\right)$$ $$\sum_1^n x^2 = 1$$ And more?Don’t forget to check Preferences, lots of useful options are there. Follow @Mou on Twitter for the latest news. For feedback, use the menu Help - Send Feedback]]></content>
    </entry>

    
  
  
</search>
